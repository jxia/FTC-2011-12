#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Motor,  mtr_S1_C1_1,     frontLeftWheel, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     frontRightWheel, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     backRightWheel, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     backLeftWheel, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     leftArm,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     rightArm,      tmotorNormal, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    leftClaw,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    rightClaw,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "Autonomous.h"
#include "JoystickDriver.c"


void drive (string auto_command, long time) {
  int left_wheelsPower;
  int right_wheelsPower;
  int WHEELSPEED = 100;

  if(auto_command=="rpoint") {
    //Check for right movement
    //Right Point Turn -- Move right tread backwards, left tread forwards
    left_wheelsPower=WHEELSPEED;
    right_wheelsPower=-WHEELSPEED;
    }else if(auto_command=="lpoint") {
    //Check for left movement
    //Left Point Turn -- Move right tread forwards, left tread backwards
    left_wheelsPower=-WHEELSPEED;
    right_wheelsPower=WHEELSPEED;
    }else if(auto_command=="up") {
    //Check for up movement
    //Forward -- Move both treads forwards
    left_wheelsPower=WHEELSPEED;
    right_wheelsPower=WHEELSPEED;
    }else if(auto_command=="down") {
    //Check for down movement
    //Backward -- Move both treads backwards
    left_wheelsPower=-WHEELSPEED;
    right_wheelsPower=-WHEELSPEED;
    }else if(auto_command=="rswing") {	//SWING TURN RIGHT
    left_wheelsPower=WHEELSPEED;
    right_wheelsPower=0;
    }else if(auto_command=="lswing") {	//SWING TURN LEFT
    left_wheelsPower=0;
    right_wheelsPower=WHEELSPEED;
    }else if(auto_command=="lswingback") {	//SWING TURN BACKWARDS LEFT
    left_wheelsPower=0;
    right_wheelsPower=-WHEELSPEED;
    }else if(auto_command=="rswingback") {	//SWING TURN BACKWARDS RIGHT
    left_wheelsPower=-WHEELSPEED;
    right_wheelsPower=0;
    }else {
    //Do not move
    left_wheelsPower=0;
    right_wheelsPower=0;
  }

  //Drive Code
  motor[frontLeftWheel] = left_wheelsPower;
  motor[backLeftWheel] = left_wheelsPower;
  motor[frontRightWheel] = right_wheelsPower;
  motor[backRightWheel] = right_wheelsPower;
  wait1Msec(time);
  motor[frontLeftWheel] = 0;
  motor[backLeftWheel] = 0;
  motor[frontRightWheel] = 0;
  motor[backRightWheel] = 0;
  return;
}

task main(){
  //Code: drive(auto_command,time);
  //replace auto_command and time with values necessary (if you don't replace them, code won't run)
  //auto_command values are: "rpoint", "lpoint", "up", "down", "rswing", "lswing", "rswingback", "lswingback"
  //time values is the time, in milliseconds, you want the robot to be doing the action specified in auto_command

  //Info:
  //Motor at 75% power travels at 2 feet per second = 60.96 cm
  //Lpoint turn takes 750 ms to turn 90 degrees

  //Use the sonar sensor by: SensorValue[sonarSensor].  It can get a distance from 0cm to 80cm
  //drive("up", 10000);      move forward 10000 milliseconds (10sec)
  //drive("lpoint", 1000);   left point turn for 1000 milliseconds (1sec)
  //drive("up", 10000);      move forward again for 10000 milliseconds (10sec)

  waitForStart();

  long distance = 0;

  /*
  int count = 0;

  string BatteryLevel = externalBatteryAvg;
  string selection = "";


  nxtDisplayCenteredBigTextLine (3, BatteryLevel);
  wait1Msec(3000);
  */

  //0) Move off of home zone
  distance = 1650;
  drive("up", distance);

  //1) Measure offset from walls
  //Convert offset distance into milliseconds

  // Turn left 90 degrees and measure
  distance = 870;
  drive("rpoint", distance);
  //offset_right = (SensorValue[sonarSensor]/60.96) * 1000;

  //Remeasure
  //offset_back = ((SensorValue[sonarSensor]/60.96) * 1000) - 1958.3333;


  //2) Move forward ((Four Feet Seven Inches=139.7 cm)-offset_back)

  distance = 2000;
  drive("up", distance);

  //3) Point turn 90 degrees

  distance = 420;
  drive("rpoint", distance);

  distance = 2000;
  drive("up", distance);
/*
  //4) Move forward ((Four Feet Eight Inches=142.24 cm)-(the robot's length)-offset_right)
/////
  distance = 2333.333333 - robot_length - offset_right;
  drive("up", distance);

  //5) Point turn -33.7 degrees

  distance = 280.833333;
  drive("lpoint", distance);

  //6) Move forward ((Seven Feet 2.5 Inches=219.71 cm)-(the robot's length))

  distance = 3604.1666666 - robot_length;
  drive("up", distance);

  //7) Pause 1 second

  wait1Msec(1000);

  //8) Move backward (Three Inches=7.62 cm)

  distance = 125;
  drive("down", distance);

  //9) Point turn 33.7 degrees

  distance = 280.833333;
  drive("rpoint", distance);

  //10) Measure offset from RED base wall (should be from 5' - 7' = 152.4-213.36 cm)
  offset_right = (SensorValue[sonarSensor]/60.96) * 1000;

  //11) Move backward until (offset=(Two Feet Six Inches = 76.2 cm))
  //OR Move backward (Two Feet Four Inches = 71.12 cm)
  //Robot will move into RED Low Zone

  //while offset_right > 857 {
  //  drive("down", 500);
  //  offset_right = SensorValue[sonarSensor]/60.96;
  //}
  //OR
  distance = 857;
  drive("down", distance);

  //12) Point Turn 90 degrees

  distance = 750;
  drive("rpoint", distance);

  //13) Measure offset
  offset_back = (SensorValue[sonarSensor]/60.96) * 1000;

  //14) Move until (offset=(Ten Feet Six Inches = 320.04 cm)-(half the robot's length))
  //OR Move forward (Nine Feet Eight Inches = 294.64 cm)

  //while offset_back > 5250 {
  //  drive("up", 500);
  //  offset_right = SensorValue[sonarSensor]/60.96;
  //}
  //OR
  distance = 4833.33333;
  drive("up", distance);

  //15) Point Turn 90 Degrees

  distance = 750;
  drive("rpoint", distance);

  //16) Move forward (Five Feet Six Inches = 167.64 cm)

  distance = 2750;
  drive("up", distance);*/
}
