#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,                    sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     frontLeftWheel, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     frontRightWheel, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     backRightWheel, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     backLeftWheel, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     leftArm,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     rightArm,      tmotorNormal, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    leftClaw,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    rightClaw,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"


void drive (int auto_command, long time) {
  int left_wheelsPower;
  int right_wheelsPower;
  int WHEELSPEED = 100;

  if(auto_command==0) {
    //Check for forward movement
    left_wheelsPower=WHEELSPEED;
    right_wheelsPower=WHEELSPEED;
    }else if(auto_command==4) {
    //Check for backwards movement
    left_wheelsPower=-WHEELSPEED;
    right_wheelsPower=-WHEELSPEED;
    }else if(auto_command==2) {
    //Check for right movement
    left_wheelsPower=WHEELSPEED;
    right_wheelsPower=0;
    }else if(auto_command==6) {
    //Check for left movement
    left_wheelsPower=0;
    right_wheelsPower=WHEELSPEED;
    }else {
    //Do not move
    left_wheelsPower=0;
    right_wheelsPower=0;
  }

  //Drive Code
  motor[frontLeftWheel] = left_wheelsPower;
  motor[backLeftWheel] = left_wheelsPower;
  motor[frontRightWheel] = right_wheelsPower;
  motor[backRightWheel] = right_wheelsPower;
  wait1Msec(time);
  motor[frontLeftWheel] = 0;
  motor[backLeftWheel] = 0;
  motor[frontRightWheel] = 0;
  motor[backRightWheel] = 0;
  return;
}

task main(){
  //Code: drive(auto_command,time);
  //replace auto_command and time with values necessary (if you don't replace them, code won't run)
  //auto_command values are: "rpoint", "lpoint", "up", "down", "rswing", "lswing", "rswingback", "lswingback"
  //time values is the time, in milliseconds, you want the robot to be doing the action specified in auto_command

  //Use the sonar sensor by: SensorValue[sonarSensor].  It can get a distance from 0cm to 80cm
  //drive("up", 10000);      move forward 10000 milliseconds (10sec)
  //drive("lpoint", 1000);   left point turn for 1000 milliseconds (1sec)
  //drive("up", 10000);      move forward again for 10000 milliseconds (10sec)


  waitForStart();

  /*
  int count = 0;

  string BatteryLevel = externalBatteryAvg;
  string selection = "";


  nxtDisplayCenteredBigTextLine (3, BatteryLevel);
  wait1Msec(3000);
  */

  string arresteddev = "redcliff";  //!IMPORTANT - options are "redwall", "redcliff", "bluwall", "blucliff"

  if(arresteddev == "bluwall") {
  }else if (arresteddev == "redwall") {
  }else if (arresteddev == "redcliff") {
    drive(0,984);
		drive(65535,100);
		drive(0,656);
		drive(65535,100);
		drive(0,567);
		drive(65535,100);
		drive(0,1692);
		drive(65535,100);
		drive(6,700);
		drive(65535,100);
		drive(6,1172);
		drive(65535,100);
		drive(4,371);
		drive(65535,100);
		drive(6,893);
		drive(65535,100);
		drive(4,424);
		drive(65535,100);
		drive(6,1687);
		drive(65535,100);
		drive(0,473);
		drive(65535,100);
		drive(0,276);
		drive(65535,100);
		drive(6,236);
		drive(65535,100);
		drive(0,564);
		drive(65535,100);
		drive(6,561);
		drive(65535,100);
		drive(0,5955);
		drive(65535,100);
		drive(4,368);
		drive(65535,100);
		drive(0,236);
		drive(65535,100);
		drive(4,179);
		drive(65535,100);
		drive(0,1969);
  }else if (arresteddev == "blucliff") {
    drive(0,984);
		drive(65535,100);
		drive(0,656);
		drive(65535,100);
		drive(0,567);
		drive(65535,100);
		drive(0,1692);
		drive(65535,100);
		drive(2,700);
		drive(65535,100);
		drive(2,1172);
		drive(65535,100);
		drive(4,371);
		drive(65535,100);
		drive(2,893);
		drive(65535,100);
		drive(4,424);
		drive(65535,100);
		drive(2,1687);
		drive(65535,100);
		drive(0,473);
		drive(65535,100);
		drive(0,276);
		drive(65535,100);
		drive(2,236);
		drive(65535,100);
		drive(0,564);
		drive(65535,100);
		drive(2,561);
		drive(65535,100);
		drive(0,5955);
		drive(65535,100);
		drive(4,368);
		drive(65535,100);
		drive(0,236);
		drive(65535,100);
		drive(4,179);
		drive(65535,100);
		drive(0,1969);
  }else {  //Blucliff default
    drive(0,984);
		drive(65535,100);
		drive(0,656);
		drive(65535,100);
		drive(0,567);
		drive(65535,100);
		drive(0,1692);
		drive(65535,100);
		drive(2,700);
		drive(65535,100);
		drive(2,1172);
		drive(65535,100);
		drive(4,371);
		drive(65535,100);
		drive(2,893);
		drive(65535,100);
		drive(4,424);
		drive(65535,100);
		drive(2,1687);
		drive(65535,100);
		drive(0,473);
		drive(65535,100);
		drive(0,276);
		drive(65535,100);
		drive(2,236);
		drive(65535,100);
		drive(0,564);
		drive(65535,100);
		drive(2,561);
		drive(65535,100);
		drive(0,5955);
		drive(65535,100);
		drive(4,368);
		drive(65535,100);
		drive(0,236);
		drive(65535,100);
		drive(4,179);
		drive(65535,100);
		drive(0,1969);
  }
}
